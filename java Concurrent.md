# Java并发

标签（空格分隔）： Java学习

---

## 串行编程模型
安全性问题
活跃性问题
性能问题
三种方式修复问题：

 - 不在线程间共享该状态变量
 - 将状态变量改为不可变的变量
 - 在访问状态变量时使用同步
## 线程安全
当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，主调代码不需要任何额外的同步或者协同，这个类都会表现出正确的行为。
## 竞态条件（Race Condition）
由于不恰当的执行时序而出现<font size=5 color="blue">不正确</font>的结果
常见的竞态条件的类型“先检查——后执行 Check then Act”
这种类型下，其本质是“基于一个可能失效的观测结果来做出判断或者执行某个计算”
两人去一个地方的一个星巴克会面
## 原子操作
不可分割和被打扰的一些复合操作 java.util.concurrent.atomic 
## 加锁机制
 - 内置锁（Intrinsic Lock）
    synchronize（lock）{}
    获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或者方法
 - 重入
    一个线程请求自己已经获得的锁，那么它不会阻塞，而是会成功。（如继承父类的synchronized方法）
## 活跃性与性能 ##
当执行时间较长的计算或者可能无法快速完成的操作时（例如网络IO或者控制台IO），一定不要持有锁

# 对象的共享 #
## 内存可见性 ##


- 防止某个线程使用对象状态而另一个线程同时修改对象状态

- 希望某个线程修改了对象状态后，其他线程能够看到发生的状态变化

### 可见性 ###
在没有同步的情况下，编译器、处理器以及运行时都可能对操作的顺序进行一些意想不到的调整
#### 非原子的64位操作 ####
**Java内存模型要求，变量的读取和写入操作都必须是原子操作**，但是对非volatile类型的long和double变量，JVM允许32位，32位地读
#### 加锁与可见性 ####
加锁除了保证**互斥行为**，还保证**内存可见性**，为了所有线程都能看到共享变量的最新值，所有读写操作必须在同一个锁上同步
#### volatile变量 ####
volatile是一种比synchronized关键字更轻量级的同步机制，
通常是告诉编译器，不要进行编译优化、重排、缓存等
加锁机制既可以确保可见性又可以确保原子性，而volatile只能确保可见性。
**当且仅当**满足一下所有条件时，才应该使用volatile

- 对变量写入不依赖当前值，或者你能确保只有一个线程更新变量的值
- 变量独立，不会与其他变量一起纳入不变性条件中
- 在访问变量时不需要加锁

## 发布与逸出 ##
发布（publish）一个对象 是指对象能够在当前作用域之外的代码中使用
逸出（escape）是指不该发布的对象（或者其内部状态）被发布

**封装**能够使得对程序的正确性进行分析变得可能，并使得无意中破坏设计约束天条件变得更难

## 线程封闭 ##
如果仅在单线程内访问数据，就不需要同步，这种技术叫做线程封闭。
如Swing的可视化组件和数据模型对象都不是线程安全的，Swing通过将它们封闭到Swing的事件分发线程中来实现线程安全性。
### Ad-hoc线程封闭 ###
### 栈封闭 ###
### ThreadLocal类 ###
ThreadLocal对象通常用于防止对可变的单实例变量（Singleton）或全局变量进行共享
ThreadLocal变量类似于全局变量，它能降低代码的可重用性，并在类之间引入隐含的耦合性，因此在使用时要格外小心
## 不变性 ##
不可变对象，满足以下条件：
- 对象创建之后其状态就不能修改
- 对象所有域都是final类型
- 对象是正确创建的（在对象创建期间，this指针没有逸出）

### Final域 ###
在java内存模型中，final域还有着特殊的语义，它能够确保初始化过程的安全性，从而可以不受限制地访问不可变对象	
“除非需要更高的可见性，否则应将所有域都声明为私有域；
除非需要某个域是可变的，否则应将其生命为final域”
### 使用volatile类型来发布不可变对象 ###
将可变状态变量集合封装到一个不可变对象（final域）中，该对象的引用是volatile的（确保正确初始化），可以实现对这些所有可变状态的同步。

## 安全发布 ##
一个正确构造的对象可以通过以下方式来安全地发布：
- 在静态初始化函数中初始化一个对象的引用
- 将对象的一弄保存到volatile类型的域或者AtomicReference对象中
- 将对象的引用保存到某个正确构造对象的final类型域中
- 将对象的引用保存到一个由锁保护的域中

通常最简单、最安全的是使用静态的初始化器
public static Holder holder = new Holder(43);
静态初始化器由JVM在类的初始化阶段执行。**JVM内部存在着同步机制**，因此其会被安全地发布。

发布时要说明对象的访问方式
- 线程封闭
- 只读共享（不可变、事实不可变）
- 线程安全共享（对象内部实现同步，调用对象的共有方法，不需要进一步同步）
- 保护对象（通过持有特定的锁）

# 对象的组合 #

希望将一些线程安全的组件组合为更大规模的组件或程序
## 设计线程安全的类 ##
包含以下三个要素：

- 找出构成对象状态的所有变量
- 找出约束状态变量的不变性条件
- 建立对象状态的并发访问管理策略

### 收集同步需求 ###
不变性条件和后验条件
### 依赖状态的操作 ###
状态的先验条件（Precondition）
### 状态的所有权 ###
所有权意味着控制权，如果发布了某个可变对象的引用，那么就不再拥有独占的“控制权”，而是“共享控制权”。
## 实例封闭（Instance Confinement) ##
线程不安全的对象可以封闭在类的一个实例（私有成员），或者封闭在某个作用域内（局部变量），或者封闭在一个线程内（线程一个方法传递给另一个方法），此过程中该对象不要逸出。
java中一些容器类本身不是线程安全的，例如ArrayList和HashMap，但是类库中提供了包装器的工厂方法（Collections.synchronizedList），这些工厂方法将容器类封装在一个同步的包装器对象上，包装器对象中都是同步方法。
### Java监视器模式 ###
遵循Java监视器模式的对象会把对象的所有可变状态都封装起来，并由对象自己的内置锁来保护。
## 线程安全性的委托 ##
## 4.4 在现有线程安全类中添加功能 ##
### 客户端加锁机制 ###
### 组合 ###
## 4.5 将同步策略文档化 ##

# 第五章 基础构建模块 #

## 5.1 同步容器类 ##
如vector和Hashtable等，它们将状态封装起来，对每个共有方法进行同步
### 同步容器类的问题 ###
复合操作并不是原子性，比如迭代
### 迭代器与ConcurrentModificationException ###
迭代器“即使失败”（fail-fast)
## 5.2 并发容器 ##
通过并发容器来代替同步容器，可以极大地提高伸缩性并降低风险。
不要使用synchronized包装容器类，而是使用concurrent包的容器
它们有着更多的优势以及更少的劣势，可以进一步提高代码的可伸缩性，只有当应用程序需要加锁Map以进行独占访问时，才应该放弃CurrentHashMap
### ConcurrentHashMap ###
### 额外的原子Map操作 ###
若没有则添加，若相等则移除，若相等则替换等额外的原子操作
### CopyOnWriteArrayList ###
替代List，迭代期间不需要对容器进行加锁或复制
其安全性在于：只要正确地发布一个事实不可变对象，那么在访问该对象时就不再需要进一步的同步。
仅当迭代操作远远多于修改操作时，才应该使用“写入时复制”容器